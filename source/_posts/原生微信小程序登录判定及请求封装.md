---
title: 原生微信小程序登录判定及请求封装
date: 2019-03-25 09:52:16
tags: JavaScript
categories: 微信小程序
---

# 初开发时的思考

第一次独立开发小程序，本身技术不太好，对于这些考虑的不太全面，直接封装请求函数，接着在app.js或者在首页index.js中初始化时进行微信登录。

请求函数是根据之前同事在mpvue上使用的，在参考网上的一些代码，修改而成的，如下：

```js
let baseUrl = 'https://xxx.com';
function request(options) {
    return new Promise((resolve, reject) => {
        wx.request({
            url: baseUrl + options.url,
            data: options.data,
            header: Object.assign({
                'content-type': 'application/json',
                'haferd-autoclub-token': wx.getStorageSync('myToken')
            }),
            method: options.method,
            success(res) {
                let body = res.data
                let logoutMessages = ['header_x_access_token_invalid','WxApplets Request Must Need Session Id','Unauthorized']
                if (body.code === 401 || logoutMessages.includes(body.message)) {
                    // 登录超时
                    console.log('登录超时')
                    return
                }
                console.log('错误')
                reject(body.message)
            },
            fail(err) {
                console.error(err)
                reject(err.errMsg || '请求出错')
            }
        })
    })
}
module.exports = {
    request: req
}
```

因为Vue是有状态管理的，原生微信小程序不知道有没，所以在登录超时后不知道怎么处理，导致后面出现一些bug。原本想着每次初始化的时候都会去登录，然后改变token，应该永远不会超时才是，但是结果并不是这样。因为这些bug不影响大局，只是时而出现，也就没做处理了，想着等初版开发完后再来优化。

# 优化时的思考

## 方案一：直接在判断登录超时后，执行微信登录。

测试发现并不可行，虽然登录过后可以获取到最新的token，但是无法刷新页面，放弃。也在测试的过程中，发现为什么每次初始化的时候登录，还会登录超时，可能是因为请求是异步的，数据什么时候回来不知道，后面请求的接口用的是之前的token，导致过时了。

## 方案二：网上寻找其他登录，请求方案

[原文内容](https://www.jianshu.com/p/edd9a1aac8bd)，在此表示感谢

### 执行逻辑：请求跟登录都在一个模块里，在发起请求的时候执行登录，详细如下

1. 请求

   ```js
    function request(options) {
        return new Promise((resolve, reject) => {
            wx.request({
                url: baseUrl + options.url,
                data: options.data,
                header: Object.assign({
                    'content-type': 'application/json',
                    'haferd-autoclub-token': wx.getStorageSync('myToken')
                }),
                method: options.method,
                success(res) {
                    resolve(res.data)
               },
                fail(err) {
                    console.error(err)
                    reject(err.errMsg || '请求出错')
                }
            })
        })
    }
   ```

2. 登录

   ```js
    function login() {
        return new Promise((res, rej) => {
            // 微信登录
            wx.login({
                success(r1) {
                    if (r1.code) {
                        // 获取token
                        request({
                            url: `/url`,
                            method: 'post'
                        }).then((r2) => {
                            wx.setStorageSync('myToken', r2.token)
                            res(r2);
                        }).catch((err) => {
                            rej(err);
                        });
                    } else {
                        rej({
                            msg: '获取code失败'
                        });
                    }
                },
                fail(err) {
                    rej(err);
                }
            });
        });
    }
   ```

3. token

   ```js
    function getToken() {
        return new Promise((res, rej) => {
            // 本地Token丢失，重新登录
            if (!wx.getStorageSync('myToken')) {
                login().then((r) => {
                    res(r.token)
                }).catch((err) => {
                    rej(err)
                });
            }
            } else {
                res(wx.getStorageSync('myToken'))
            }
        })
    }
   ```

4. 并发的考虑，登录超时的时候，同时发出多个请求，登录会被多次调用，修改如下：

   ```js
    let loginQueue = [];
    let isLoginning = false;
    function getToken() {
        return new Promise((res, rej) => {
            loginQueue.push({
                res,
                rej
            });
            if (!isLoginning) {
                isLoginning = true;
                login().then((r) => {
                    isLoginning = false;
                    loginQueue.map(q => q.res(r.token));
                    loginQueue = [];
                }).catch((err) => {
                    isLoginning = false;
                    loginQueue.map(q => q.rej(err));
                    loginQueue = [];
                });
            }
            } else {
                res(wx.getStorageSync('myToken'))
            }
        })
    }
   ```

5. 最终统合

   ```js
    function req(options) {
        return new Promise((res, rej) => {
            getToken().then((r1) => {
                // 获取token成功之后，发起请求
                request(options).then((r2) => {
                    let logoutMessages = ['header_x_access_token_invalid', 'WxApplets Request Must Need Session Id', 'Unauthorized']
                    if (r2.code === 401 || logoutMessages.includes(r2.message)) {
                        // 登录状态无效，则重新走一遍登录流程
                        // 销毁本地已失效的token
                        wx.setStorageSync('myToken', '')
                        getToken().then((r3) => {
                            request(options).then((r4) => {
                                res(r4);
                            }).catch((err) => {
                                rej(err);
                            });
                        });
                    } else {
                        res(r2);
                    }
                }).catch((err) => {
                    // 请求出错
                    rej(err);
                });
            }).catch((err) => {
                // 获取Token失败
                rej(err);
            });
        });
    }
   ```

# 总结：

虽然想到了在登录超时的时候再次执行登录，但对登录的执行时机选择不一样，想的还是以前点击按钮登录的模式，想不到发送接口前登录这种情况，思维僵化了，还有封装想的不够全面，可以把所有的接口封装在一个方法里面，页面直接调用方法请求数据，对请求并发的考虑，可能还没遇到吧！但纵使遇到了，也想不到这样的解决办法，还得努力学习